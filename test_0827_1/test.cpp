//#define _CRT_SECURE_NO_WARNINGS 1
//
//一、指针和引用的定义和性质区别
//（1）指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体；而引用跟原来的变量实质上是一个东西，只不过是原变量的一个别名而已。如：
//
//int a = 1; int* p = &a;
//int a = 1; int& b = a;
//1
//2
//上面定义了一个整型变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。
//
//而下面2句定义了一个整型变量a和这个整型a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。
//
//（2）可以有const指针，但是没有const引用；
//（3）指针可以有多级，但是引用只能是一级（int * *p；合法 而 int&& a是不合法的）；
//（4）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；
//（5）指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了，从一而终。
//（6）sizeof引用得到的是所指向的变量(对象)的大小，而sizeof指针得到的是指针本身的大小；
//（7）指针和引用的自增(++)运算意义不一样；
//
//二、相同点
//
//都是地址的概念；
//
//指针指向一块内存，它的内容是所指内存的地址；
//
//引用是某块内存的别名。
//
//三、联系
//
//1、引用在语言内部用指针实现（如何实现？）。
//
//2、对一般应用而言，把引用理解为指针，不会犯严重语义错误。引用是操作受限了的指针（仅容许取内容操作）。
//
//引用的一些规则如下：
//
//（1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
//（2）不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
//（3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
//
//上面的程序看起来象在玩文字游戏，没有体现出引用的价值。引用的主要功能是传递函数的参数和返回值。C++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。
//
//“引用传递”的性质像“指针传递”，而书写方式像“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用”这东西？
//
//答案是“用适当的工具做恰如其分的工作”。
//
//指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。
//
//就象一把刀，它可以用来砍树、裁纸、修指甲、理发等等，谁敢这样用？
//
//如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。比如说，某人需要一份证明，本来在文件上盖上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。
//
//总的来说，在以下情况下你应该使用指针：
//
//一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），
//
//二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。
//
//还有一种情况，就是当你重载某个操作符时，你应该使用引用。
//
//尽可能使用引用，不得已时使用指针。
//
//当你不需要“重新指向”时，引用一般优先于指针被选用。这通常意味着引用用于类的公有接口时更有用。引用出现的典型场合是对象的表面，而指针用于对象内部。